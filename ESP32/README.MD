# ‚öôÔ∏è C√≥digo Fonte: Monitoramento IoT Industrial - NORVI GSM AE04 L (ESP32)

---

Este documento descreve o c√≥digo-fonte C++ desenvolvido para o microcontrolador **ESP32** embutido no m√≥dulo **NORVI GSM AE04 L**. O programa √© respons√°vel por:

1. Estabelecer conex√£o Wi-Fi e MQTT.
2. Ler dados anal√≥gicos (Corrente, Vaz√£o, Press√£o) atrav√©s do conversor **ADS1115**.
3. Ler o estado de seis entradas digitais (DI0 a DI5).
4. Converter as leituras brutas em Unidades de Engenharia (UE).
5. Montar uma mensagem **JSON** com todos os dados.
6. Publicar a mensagem em um t√≥pico MQTT.

## üåü Vis√£o Geral do Hardware e Software

| Componente | Fun√ß√£o | Detalhes no C√≥digo |
| :--- | :--- | :--- |
| **NORVI GSM AE04 L (ESP32)** | Microcontrolador principal. | Lida com Wi-Fi, MQTT e l√≥gica do programa. |
| **ADS1115** | Conversor Anal√≥gico-Digital de 16-bits. | Usado para ler as entradas anal√≥gicas de 4-20mA (Corrente, Vaz√£o, Press√£o). |
| **Entradas Digitais (DI0-DI5)** | Leitura de sensores digitais (e.g., status de chave/rel√©). | Pinos 27, 34, 35, 14, 13, 5. |
| **Protocolo** | **MQTT** | Broker: `test.mosquitto.org`, T√≥pico: `texto_norvi_wifi`. |

## üõ†Ô∏è Instala√ß√£o e Configura√ß√£o

### Pr√©-requisitos (Bibliotecas)

O projeto requer as seguintes bibliotecas na sua IDE Arduino:

* **`Adafruit_ADS1X15`**: Para comunica√ß√£o com o conversor ADC externo.
* **`PubSubClient`**: Para comunica√ß√£o via protocolo MQTT.
* **`ArduinoJson`**: Para manipula√ß√£o e serializa√ß√£o da mensagem JSON.

### Par√¢metros de Conex√£o

Antes de compilar e fazer o *upload* do c√≥digo, atualize as seguintes constantes:

| Constante | Descri√ß√£o | Exemplo Padr√£o |
| :--- | :--- | :--- |
| `ssid` | Nome da Rede Wi-Fi. | `""` |
| `password` | Senha da Rede Wi-Fi. | `""` |
| `mqtt_host` | Endere√ßo do Servidor MQTT (Broker). | `"test.mosquitto.org"` |
| `mqtt_topic` | T√≥pico para publica√ß√£o dos dados. | `"texto_norvi_wifi"` |

---

## üîå Detalhes do C√≥digo

### 1. Convers√£o de Unidades de Engenharia (UE) - Incluindo a Soma da M√≠nima da Sa√≠da

As fun√ß√µes de c√°lculo (`calcularCorrente`, `calcularVazao`, `calcularPressao`) implementam a **interpola√ß√£o linear**, essencial para mapear o valor digital (ADC) para a escala real do sensor (UE).

O c√°lculo agora adiciona a **M√≠nima da Sa√≠da** ($\mathbf{UE_{\text{m√≠n}}}$), garantindo que a escala comece no valor m√≠nimo configurado, o que √© fundamental para sensores com *offset* ou calibra√ß√£o de zero.

| Medi√ß√£o | F√≥rmula (Interpola√ß√£o Linear) | Vari√°vel M√≠nima da Sa√≠da (`MIN_SAIDA`) |
| :--- | :--- | :--- |
| **Corrente** | $\text{UE} = \left(\frac{\text{corrente\_max} - \text{corrente\_min}}{\text{canal\_max} - \text{canal\_min}}\right) \times \text{valor\_adc} \mathbf{+ \text{corrente\_min}}$ | `corrente_min` (Valor atual: 0.0) |
| **Vaz√£o** | $\text{UE} = \left(\frac{\text{vazao\_max} - \text{vazao\_min}}{\text{canal\_max} - \text{canal\_min}}\right) \times \text{valor\_adc} \mathbf{+ \text{vazao\_min}}$ | `vazao_min` (Valor atual: 0.0) |
| **Press√£o** | $\text{UE} = \left(\frac{\text{pressao\_max} - \text{pressao\_min}}{\text{canal\_max} - \text{canal\_min}}\right) \times \text{valor\_adc} \mathbf{+ \text{pressao\_min}}$ | `pressao_min` (Valor atual: 0.0) |

***

### 2. Leitura de Entradas Digitais

O c√≥digo l√™ o estado dos pinos de entrada digital (DI0 a DI5) e inverte a l√≥gica (`1` = `false`, `0` = `true`) antes de armazenar os valores nas vari√°veis booleanas que ser√£o publicadas.

### 3. Montagem e Publica√ß√£o JSON

O objeto `StaticJsonDocument<300> doc;` √© usado para criar o *payload* da mensagem MQTT, que √© publicado a cada **5 segundos** (`delay(5000)`).

| Campo JSON | Origem | Tipo |
| :--- | :--- | :--- |
| `entrada_digital_1` a `entrada_digital_6` | Estado das entradas digitais (String: "true" / "false"). | String |
| `Corrente` | Valor convertido em Amperes. | Float |
| `Pressao` | Valor convertido em bar. | Float |
| `vazao` | Valor convertido em $\text{m}^3/\text{h}$. | Float |
